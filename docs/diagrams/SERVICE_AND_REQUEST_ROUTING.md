# Service-to-Service Authentication and Request Routing Flow Diagrams

This document provides detailed step-by-step instructions for drawing service-to-service authentication and API Gateway request routing flow diagrams for the Decode Network Backend system.

---

## 1. Service-to-Service Authentication Flow Diagram

### Overview
Microservices communicate with each other using service JWT tokens. These tokens are generated by the calling service and validated by the receiving service to ensure secure inter-service communication.

### Diagram Type
**Sequence Diagram** (recommended) or **Flowchart**

### Step-by-Step Drawing Instructions

#### Actors/Components to Include:
1. **Calling Service** (e.g., Auth Service, Wallet Service)
2. **ServicesJwtStrategy** (in calling service)
3. **Service Guard** (in receiving service)
4. **Receiving Service** (e.g., User Service, Auth Service)
5. **Config Service** (JWT configuration)

#### Flow Steps:

**Step 1: Service Needs to Call Another Service**
- **Calling Service** (e.g., Auth Service) needs to make a request to **Receiving Service** (e.g., User Service)
- Example: Auth Service needs to check if a user exists by email/username
- **Calling Service** instantiates the appropriate service client (e.g., `UserServiceClient`)

**Step 2: Generate Service JWT Token**
- **Calling Service** calls `ServicesJwtStrategy.createUserServicesToken()` (or appropriate method)
- **ServicesJwtStrategy** creates JWT payload:
  ```json
  {
    "from_service": "decode-auth-service",
    "to_service": "decode-user-service",
    "iat": 1234567890,
    "exp": 1234571490
  }
  ```
- Token is signed using:
  - Secret: `JWT_SERVICE_TOKEN_SECRET` (from environment)
  - Issuer: Service-specific issuer (e.g., `decode-auth-service`)
  - Audience: Target service audience (e.g., `decode-user-service`)
  - Expires In: Configured TTL (e.g., 1 hour)

**Step 3: Include Token in Request Headers**
- **Calling Service** includes token in HTTP request:
  ```
  Authorization: Bearer <service_jwt_token>
  Content-Type: application/json
  User-Agent: Auth-Service/1.0
  ```
- Request is made via HTTP client (e.g., `BaseHttpClient`)

**Step 4: Request Reaches Receiving Service**
- **Receiving Service** receives HTTP request
- Request goes through NestJS middleware stack
- Route is matched to appropriate controller endpoint

**Step 5: Service Guard Activation**
- Controller endpoint is protected with `@UseGuards(AuthServiceGuard)` decorator
- **AuthServiceGuard** (or appropriate service guard) is activated
- Guard extracts token from `Authorization` header:
  ```typescript
  const authHeader = request.headers.authorization;
  const [type, token] = authHeader.split(' ');
  // type should be "Bearer"
  // token is the service JWT token
  ```

**Step 6: Token Validation**
- **Service Guard** calls `ServicesJwtStrategy.validateAuthServicesToken(token)`
- **ServicesJwtStrategy** verifies token:
  - Verifies JWT signature using `JWT_SERVICE_TOKEN_SECRET`
  - Validates issuer matches expected issuer (e.g., `decode-auth-service`)
  - Validates audience matches expected audience (e.g., `decode-user-service`)
  - Checks token expiration (`exp` claim)
  - Validates `from_service` and `to_service` claims

**Step 7: Validation Result**
- Two possible outcomes:
  - **Valid Token**: Continue to Step 8
  - **Invalid Token**: Throw `UnauthorizedException` with error:
    ```json
    {
      "message": "Invalid service token",
      "error": "INVALID_SERVICE_TOKEN"
    }
    ```

**Step 8: Allow Request**
- If token is valid, **Service Guard** returns `true`
- Request proceeds to controller handler
- Controller executes business logic
- Response is returned to **Calling Service**

**Step 9: Response Handling**
- **Calling Service** receives response
- Response is processed and returned to original caller

### Service Token Types:

#### Auth Service → User Service Token
- **Issuer**: `decode-auth-service`
- **Audience**: `decode-user-service`
- **Method**: `createUserServicesToken()`
- **Used For**: User data operations (create, read, update)

#### Wallet Service → Auth Service Token
- **Issuer**: `decode-wallet-service`
- **Audience**: `decode-auth-service`
- **Method**: `createAuthServicesToken()`
- **Used For**: Wallet session creation

### Error Paths to Include:
1. **Missing Token**: `MISSING_SERVICE_TOKEN` error
2. **Invalid Token Signature**: Token verification fails
3. **Wrong Issuer**: Token issuer doesn't match expected service
4. **Wrong Audience**: Token audience doesn't match target service
5. **Expired Token**: Token has expired
6. **Invalid from_service/to_service**: Claims don't match expected values

### Visual Elements:
- Use different colors for:
  - Token generation (blue)
  - Token validation (green)
  - Error paths (red)
- Show token payload structure
- Include configuration values (issuer, audience, secret)
- Show HTTP headers clearly

---

## 2. API Gateway Request Routing Flow Diagram

### Overview
The API Gateway acts as a single entry point for all client requests. It routes requests to appropriate microservices, handles authentication, transforms responses, and manages errors.

### Diagram Type
**Sequence Diagram** (recommended) or **Flowchart with Swimlanes**

### Step-by-Step Drawing Instructions

#### Actors/Components to Include:
1. **Client** (Web/Mobile App)
2. **API Gateway** (Port 4000)
   - Middleware Stack
   - Guards
   - Interceptors
   - Controllers
   - Services
   - External Service Clients
3. **Auth Service** (Port 4001)
4. **User Service** (Port 4002)
5. **Wallet Service** (Port 4005)
6. **Relationship Service** (Port 4004)
7. **Notification Service** (Port 4006)
8. **Redis** (Port 6379) - for caching
9. **MongoDB** (Port 27017) - for session storage

#### Flow Steps:

**Step 1: Client Request**
- **Client** sends HTTP request to API Gateway
- Example: `POST /auth/login`
- Request includes:
  - Headers: `Content-Type: application/json`
  - Body: `{ "email_or_username": "...", "password": "...", ... }`
  - Optional: `Authorization: Bearer <access_token>` (for authenticated requests)

**Step 2: Request Reaches API Gateway**
- Request arrives at **API Gateway** (Port 4000)
- NestJS application receives request
- Request enters middleware stack

**Step 3: Middleware Processing (Order Matters)**
- **CORS Middleware**: Handles cross-origin requests
  - Validates origin
  - Adds CORS headers to response
- **Helmet Middleware**: Adds security headers
  - X-Content-Type-Options
  - X-Frame-Options
  - X-XSS-Protection
  - etc.
- **Request ID Middleware**: Generates unique request ID
  - UUID v4 generation
  - Attaches to request: `request.requestId`
- **Request Logger Middleware**: Logs request details
  - Method, URL, headers, IP address
  - Timestamp

**Step 4: Route Matching**
- NestJS router matches request to controller
- Example: `POST /auth/login` → `AuthController.login()`
- Route parameters extracted if applicable

**Step 5: Global Validation Pipe**
- **ValidationPipe** processes request body
- Validates against DTO (Data Transfer Object)
- Rules:
  - `whitelist: true` - Strips non-whitelisted properties
  - `forbidNonWhitelisted: true` - Throws error for extra properties
  - `transform: true` - Transforms to DTO instance
- If validation fails → throw `BadRequestException`

**Step 6: Authentication Check (If Required)**
- Check if route is marked as `@Public()`
- If not public:
  - **AuthGuard** is activated
  - Extract `Authorization` header
  - Extract access token from `Bearer <token>`
  - **AuthGuard** calls **Auth Service** to validate token:
    ```
    POST /auth/info/by-access-token
    Body: { "access_token": "..." }
    ```
  - **Auth Service** validates token and returns user info
  - **AuthGuard** caches result in memory (5 minutes TTL)
  - Attach user to request: `request.user`
  - Check role-based access if `@Roles()` decorator present
- If public route → skip authentication

**Step 7: Rate Limiting Check**
- Check rate limit decorators:
  - `@AuthRateLimit.login()` - For login endpoints
  - `@UserRateLimit.standard()` - Standard user rate limit
  - `@UserRateLimit.strict()` - Strict rate limit
- Rate limiting uses **Redis** to track request counts
- If limit exceeded → return `429 Too Many Requests`

**Step 8: Controller Handler Execution**
- Controller method is called
- Example: `AuthController.login(loginDto)`
- Controller calls corresponding service:
  - `AuthService.login(loginDto)`

**Step 9: Service Layer Processing**
- **AuthService** processes request
- Service calls external service client:
  - `AuthServiceClient.login(loginDto)`
- **AuthServiceClient** extends `BaseHttpClient`
- **BaseHttpClient**:
  - Injects Datadog trace headers (for distributed tracing)
  - Makes HTTP request to **Auth Service**:
    ```
    POST http://auth:4001/auth/login
    Headers: {
      "Content-Type": "application/json",
      "x-datadog-trace-id": "...",
      "x-datadog-parent-id": "..."
    }
    Body: { ... }
    ```
  - Sets timeout: 10 seconds
  - Records metrics (duration, status code, errors)

**Step 10: Downstream Service Processing**
- **Auth Service** receives request
- Processes request (as per authentication flow)
- Returns response:
  ```json
  {
    "success": true,
    "statusCode": 200,
    "message": "Login successful",
    "data": { ... }
  }
  ```

**Step 11: Response Received by API Gateway**
- **BaseHttpClient** receives response
- Handles response:
  - If `success: false` → Map to appropriate exception
  - Record metrics (duration, status code)
  - Return response data

**Step 12: Interceptor Processing (Response)**
- Response passes through interceptors (in reverse order):
  - **MetricsInterceptor**: Records HTTP metrics
    - Request duration
    - Request count
    - Request/response size
    - Error counts
  - **ResponseTransformInterceptor**: Standardizes response format
    - Ensures response has `success`, `statusCode`, `message`, `data`
    - Adds `requestId` to response
  - **RequestIdInterceptor**: Ensures request ID is in response

**Step 13: Exception Filter (If Error Occurred)**
- If exception was thrown:
  - **ValidationExceptionFilter**: Formats validation errors
  - **HttpExceptionFilter**: Formats HTTP exceptions
  - Converts to standard error response:
    ```json
    {
      "success": false,
      "statusCode": 400,
      "message": "Validation failed",
      "error": "VALIDATION_ERROR",
      "requestId": "..."
    }
    ```

**Step 14: Response Sent to Client**
- Final response sent to **Client**
- Response includes:
  - Standardized format
  - Request ID for tracing
  - Appropriate status code
  - CORS headers (if applicable)
  - Security headers

### Request Routing Examples:

#### Example 1: Public Endpoint (Login)
```
Client → API Gateway → CORS → Helmet → RequestID → Logger
  → ValidationPipe → Controller → Service → AuthServiceClient
  → Auth Service → Response → Interceptors → Client
```

#### Example 2: Protected Endpoint (Get User Profile)
```
Client → API Gateway → CORS → Helmet → RequestID → Logger
  → ValidationPipe → AuthGuard → Auth Service (validate token)
  → Rate Limit Check → Controller → Service → UserServiceClient
  → User Service → Response → Interceptors → Client
```

#### Example 3: Service-to-Service Call (Auth → User)
```
Auth Service → UserServiceClient → Generate Service Token
  → HTTP Request with Service Token → User Service
  → Service Guard → Validate Token → Controller → Response
```

### Route Mapping:

| Client Route | API Gateway Controller | Target Service | Service Endpoint |
|--------------|------------------------|----------------|------------------|
| `POST /auth/login` | `AuthController.login()` | Auth Service | `POST /auth/login` |
| `POST /auth/register/email-verification` | `AuthController.register()` | Auth Service | `POST /auth/register/email-verification` |
| `GET /users/profile/:id` | `UsersController.getProfile()` | User Service | `GET /users/profile/:id` |
| `POST /wallet/link` | `WalletController.link()` | Wallet Service | `POST /wallet/link` |
| `POST /relationship/follow` | `RelationshipController.follow()` | Relationship Service | `POST /relationship/follow` |
| `GET /notifications` | `NotificationController.getNotifications()` | Notification Service | `GET /notifications` |

### Caching Strategy:

#### Token Validation Cache
- **Location**: In-memory Map in AuthGuard
- **Key**: Access token
- **Value**: `{ user: AuthenticatedUser, expiresAt: number }`
- **TTL**: 5 minutes
- **Purpose**: Reduce calls to Auth Service for token validation

#### Service Response Cache (Optional)
- **Location**: Redis
- **Key**: Service-specific cache keys
- **TTL**: Configurable per endpoint
- **Purpose**: Cache frequently accessed data

### Error Handling Flow:

#### Error Types:
1. **Validation Error** (400)
   - DTO validation fails
   - Handled by: `ValidationExceptionFilter`

2. **Authentication Error** (401)
   - Missing or invalid token
   - Handled by: `AuthGuard` → `UnauthorizedException`

3. **Authorization Error** (403)
   - Insufficient permissions
   - Handled by: `AuthGuard` → `ForbiddenException`

4. **Not Found Error** (404)
   - Resource not found
   - Handled by: Service → `NotFoundException`

5. **Rate Limit Error** (429)
   - Too many requests
   - Handled by: Rate limit decorator

6. **Service Unavailable** (503)
   - Downstream service unavailable
   - Handled by: `BaseHttpClient` → Timeout/Connection error

7. **Internal Server Error** (500)
   - Unexpected error
   - Handled by: `HttpExceptionFilter`

### Metrics Collection:

#### Request Metrics:
- `http.request.duration` - Request processing time
- `http.request.count` - Total request count
- `http.request.size` - Request payload size
- `http.response.size` - Response payload size
- `http.request.error` - Error count by type

#### Service Call Metrics:
- `gateway.service.call.duration` - Service call duration
- `gateway.service.call.count` - Service call count
- `gateway.service.call.failed` - Failed service calls
- `gateway.service.call.timeout` - Timeout count

### Visual Elements:
- Use swimlanes for different layers:
  - Client Layer
  - API Gateway Layer (Middleware, Guards, Controllers, Services)
  - External Service Clients Layer
  - Microservices Layer
- Use different colors for:
  - Request flow (blue)
  - Response flow (green)
  - Error flow (red)
  - Caching operations (yellow)
  - Authentication flow (purple)
- Show parallel operations (metrics, logging)
- Include timing information
- Show decision points (public vs protected, cache hit vs miss)

---

## 3. Request Transformation Flow Diagram

### Overview
Shows how requests and responses are transformed as they flow through the API Gateway.

### Diagram Type
**Flowchart** or **Data Flow Diagram**

### Step-by-Step Drawing Instructions

#### Request Transformation Steps:

**Step 1: Raw HTTP Request**
- Client sends raw HTTP request
- Headers, body, query parameters

**Step 2: Middleware Transformation**
- **CORS Middleware**: Adds CORS headers
- **Helmet Middleware**: Adds security headers
- **Request ID Middleware**: Adds `requestId` to request object

**Step 3: Validation & Transformation**
- **ValidationPipe**:
  - Strips non-whitelisted properties
  - Transforms types (string to number, etc.)
  - Validates required fields
  - Converts to DTO instance

**Step 4: Service Client Transformation**
- **BaseHttpClient**:
  - Adds trace headers (Datadog)
  - Adds service-specific headers
  - Transforms request to service format
  - Adds timeout configuration

**Step 5: Response Transformation**
- **ResponseTransformInterceptor**:
  - Ensures standard format:
    ```json
    {
      "success": boolean,
      "statusCode": number,
      "message": string,
      "data": any,
      "requestId": string
    }
    ```
  - Adds `requestId` if missing
  - Wraps non-standard responses

**Step 6: Final Response**
- Standardized response sent to client
- Includes all headers (CORS, security, etc.)

---

## 4. Error Propagation Flow Diagram

### Overview
Shows how errors propagate from microservices through API Gateway to clients.

### Diagram Type
**Sequence Diagram** with error paths

### Step-by-Step Drawing Instructions

#### Error Scenarios:

**Scenario 1: Validation Error**
1. Client sends invalid request
2. **ValidationPipe** throws `BadRequestException`
3. **ValidationExceptionFilter** catches exception
4. Formats error response
5. Returns to client with 400 status

**Scenario 2: Service Error**
1. API Gateway calls downstream service
2. Service returns error response (`success: false`)
3. **BaseHttpClient.handleUnsuccessfulResponse()** maps to exception
4. Exception propagates to controller
5. **HttpExceptionFilter** formats error
6. Returns to client with appropriate status code

**Scenario 3: Service Unavailable**
1. API Gateway calls downstream service
2. Service is down or timeout occurs
3. **BaseHttpClient** catches `ECONNREFUSED` or timeout error
4. Throws error with message
5. **HttpExceptionFilter** formats as 503 or 500
6. Returns to client

**Scenario 4: Authentication Error**
1. Client sends request without token
2. **AuthGuard** throws `UnauthorizedException`
3. **HttpExceptionFilter** formats error
4. Returns to client with 401 status

---

## Diagram Creation Guidelines

### Recommended Tools:
- **Sequence Diagrams**: PlantUML, Mermaid, Draw.io, Lucidchart
- **Flowcharts**: Draw.io, Lucidchart, Miro
- **Swimlane Diagrams**: Draw.io, Lucidchart

### Color Coding Standards:
- **Blue**: Request flow, normal operations
- **Green**: Success responses, valid operations
- **Red**: Error paths, invalid operations
- **Yellow**: Caching operations, optimization
- **Purple**: Authentication/authorization
- **Orange**: Transformation operations
- **Gray**: Infrastructure components (Redis, MongoDB)

### Symbols to Use:
- **Rectangle**: Process/Service
- **Diamond**: Decision point
- **Cylinder**: Database
- **Cloud**: External service
- **Arrow**: Data flow
- **Dashed Arrow**: Async operation
- **Double Arrow**: Request/Response pair
- **Note/Sticky Note**: Additional information

### Information to Include:
- Port numbers for all services
- HTTP methods and endpoints
- Request/response payloads (simplified)
- Error codes and messages
- Timing information (timeouts, TTL)
- Configuration values (issuers, audiences)
- Token structures
- Header information

### Best Practices:
1. Start with high-level flow, then add details
2. Show all error paths clearly
3. Include retry mechanisms
4. Show parallel operations where applicable
5. Use consistent naming conventions
6. Add legends for symbols and colors
7. Include version information
8. Document assumptions and constraints
9. Show caching strategies
10. Include metrics collection points

---

**Last Updated**: 2024
**Maintained By**: Decode Development Team
